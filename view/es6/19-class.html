<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
</head>
<body>
<script>
    /*
    class Point {
    }
    class ColorPoint extends Point {
        constructor(x, y, color) {
            super(x, y); // 调用父类的constructor(x, y)
            this.color = color;
        }
        toString() {
            return this.color + ' ' + super.toString(); // 调用父类的toString()
        }
    }
*/
/*
    class Point {
        constructor(x, y) {
            this.x = x;
            this.y = y;
        }
    }
    class ColorPoint extends Point {
//        构造函数
        constructor(x, y, color) {
            this.color = color; // ReferenceError
//            获取this
            super(x, y);
            this.color = color; // 正确
        }
    }
    let cp = new ColorPoint(25, 8, 'green');
    cp instanceof ColorPoint // true
    cp instanceof Point // true
*/
 /*
//    1.作为函数时，super()只能用在子类的构造函数之中
    class A {
        constructor() {
            console.log(new.target.name);
        }
    }
    class B extends A {
        constructor() {
            super();
        }
    }
    new A() // A
    new B() // B
*/
/*
// 2.super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。
    class A {
        p() {
            return 2;
        }
    }

    class B extends A {
        constructor() {
            super();
            console.log(super.p()); // 2
        }
    }

    let b = new B();//2
*/

//    这两条继承链，可以这样理解：作为一个对象，子类（B）的原型（__proto__属性）是父类（A）；作为一个构造函数，子类（B）的原型对象（prototype属性）是父类的原型对象（prototype属性）的实例

</script>
</body>
</html>