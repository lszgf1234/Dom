<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
</head>
<body>
<script>
 /*
//    ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。
//    es5写法
    function Point(x, y) {
        this.x = x;
        this.y = y;
    }

    Point.prototype.toString = function () {
        return '(' + this.x + ', ' + this.y + ')';
    };

//    es6写法
    class Point {
        constructor(x, y) {
            this.x = x;
            this.y = y;
        }

        toString() {
            return '(' + this.x + ', ' + this.y + ')';
        }
    }
 */
/*

// 在类的实例上面调用方法，其实就是调用原型上的方法。
 class B {}
 let b = new B();

 b.constructor === B.prototype.constructor // true

*/
/*

// Object.assign方法可以很方便地一次向类添加多个方法。
     class Point {
         constructor(){
             // ...
         }
     }

     Object.assign(Point.prototype, {
         toString(){},
         toValue(){}
     });
*/
/*
// this 的指向
 // ES6
 function foo() {
     setTimeout(() => {
         console.log('id:', this.id);
 }, 100);
 }

 // ES5
 function foo() {
     var _this = this;

     setTimeout(function () {
         console.log('id:', _this.id);
     }, 100);
 }
 */

// 除了this，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：arguments、super、new.target
// 由于箭头函数没有自己的this，所以当然也就不能用call()、apply()、bind()这些方法去改变this的指向
 class Point {}
 Point.name // "Point"
</script>
<script>
    /*
    class Point {
    }
    class ColorPoint extends Point {
        constructor(x, y, color) {
            super(x, y); // 调用父类的constructor(x, y)
            this.color = color;
        }
        toString() {
            return this.color + ' ' + super.toString(); // 调用父类的toString()
        }
    }
*/
/*
    class Point {
        constructor(x, y) {
            this.x = x;
            this.y = y;
        }
    }
    class ColorPoint extends Point {
//        构造函数
        constructor(x, y, color) {
            this.color = color; // ReferenceError
//            获取this
            super(x, y);
            this.color = color; // 正确
        }
    }
    let cp = new ColorPoint(25, 8, 'green');
    cp instanceof ColorPoint // true
    cp instanceof Point // true
*/
 /*
//    1.作为函数时，super()只能用在子类的构造函数之中
    class A {
        constructor() {
            console.log(new.target.name);
        }
    }
    class B extends A {
        constructor() {
            super();
        }
    }
    new A() // A
    new B() // B
*/
/*
// 2.super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。
    class A {
        p() {
            return 2;
        }
    }

    class B extends A {
        constructor() {
            super();
            console.log(super.p()); // 2
        }
    }

    let b = new B();//2
*/

//    这两条继承链，可以这样理解：作为一个对象，子类（B）的原型（__proto__属性）是父类（A）；作为一个构造函数，子类（B）的原型对象（prototype属性）是父类的原型对象（prototype属性）的实例

</script>
</body>
</html>